{"ast":null,"code":"import ReactHtmlParser from 'react-html-parser';\nimport axios from 'axios';\nconst headers = new Headers({\n  Accept: \"application/xml\",\n  \"Content-Type\": \"application/xml; charset=utf-8\",\n  //'content-type': 'application/x-www-form-urlencoded',\n  'Access-Control-Allow-Origin': '*',\n  'Access-Control-Allow-Methods': 'GET, POST, PUT',\n  'Access-Control-Allow-Headers': 'Content-Type',\n  mode: 'no-cors'\n});\nexport default class API {\n  /**\r\n   * @method getRSSFeedDetails static method to fetch rss feed from the url\r\n   * @param {String} RSS_URL to fetch the rss feed from the api\r\n   * @returns {Object} data is an array of objects holding title, description and link\r\n   * @returns {string} error is an error message\r\n   */\n  static async getRSSFeedDetails(RSS_URL) {\n    let result = {\n      data: [],\n      error: ''\n    };\n    let data = await axios.get(`https://cors-anywhere.herokuapp.com/${RSS_URL}`, headers).then(function (response) {\n      let data = response.data;\n      return new window.DOMParser().parseFromString(data, \"text/xml\");\n    }).then(data => {\n      const items = data.querySelectorAll(\"item\");\n      let articleList = [];\n      items.forEach(el => {\n        let article = {\n          title: this.ReplaceCDATA(el.querySelector(\"title\").innerHTML),\n          description: ReactHtmlParser(this.ReplaceCDATA(el.querySelector(\"description\").innerHTML)),\n          link: el.querySelector(\"link\").innerHTML\n        };\n        articleList.push(article);\n      });\n      result.data = articleList;\n      return result;\n    }).catch(function (error) {\n      result.error = error.message;\n      return result;\n    });\n    return data;\n  }\n  /**\r\n   * @method ReplaceCDATA is to remove the CDATA from the string using replace function\r\n   * @param {String} content \r\n   * @return {String} content without CDATA\r\n   */\n\n\n  static ReplaceCDATA(content) {\n    return content.replace(/<!\\[CDATA\\[/g, '').replace(/\\]\\]>/g, '');\n  }\n\n}","map":{"version":3,"sources":["C:/Program Files/Git/reacts/code-challenge/mylivn/rss-feed/src/api/index.js"],"names":["ReactHtmlParser","axios","headers","Headers","Accept","mode","API","getRSSFeedDetails","RSS_URL","result","data","error","get","then","response","window","DOMParser","parseFromString","items","querySelectorAll","articleList","forEach","el","article","title","ReplaceCDATA","querySelector","innerHTML","description","link","push","catch","message","content","replace"],"mappings":"AACA,OAAOA,eAAP,MAA4B,mBAA5B;AACA,OAAOC,KAAP,MAAkB,OAAlB;AACA,MAAMC,OAAO,GAAG,IAAIC,OAAJ,CAAY;AACxBC,EAAAA,MAAM,EAAE,iBADgB;AAExB,kBAAgB,gCAFQ;AAGxB;AACA,iCAA+B,GAJP;AAKxB,kCAAgC,gBALR;AAMxB,kCAAgC,cANR;AAOxBC,EAAAA,IAAI,EAAE;AAPkB,CAAZ,CAAhB;AASA,eAAe,MAAMC,GAAN,CAAU;AAErB;;;;;;AAMA,eAAaC,iBAAb,CAA+BC,OAA/B,EAAwC;AACpC,QAAIC,MAAM,GAAG;AAAEC,MAAAA,IAAI,EAAE,EAAR;AAAYC,MAAAA,KAAK,EAAE;AAAnB,KAAb;AACA,QAAID,IAAI,GAAG,MAAMT,KAAK,CACjBW,GADY,CACP,uCAAsCJ,OAAQ,EADvC,EAC0CN,OAD1C,EAEZW,IAFY,CAEP,UAAUC,QAAV,EAAoB;AACtB,UAAIJ,IAAI,GAAGI,QAAQ,CAACJ,IAApB;AACA,aAAO,IAAIK,MAAM,CAACC,SAAX,GAAuBC,eAAvB,CAAuCP,IAAvC,EAA6C,UAA7C,CAAP;AACH,KALY,EAMZG,IANY,CAMPH,IAAI,IAAI;AACV,YAAMQ,KAAK,GAAGR,IAAI,CAACS,gBAAL,CAAsB,MAAtB,CAAd;AACA,UAAIC,WAAW,GAAG,EAAlB;AACAF,MAAAA,KAAK,CAACG,OAAN,CAAeC,EAAD,IAAQ;AAClB,YAAIC,OAAO,GAAG;AACVC,UAAAA,KAAK,EAAE,KAAKC,YAAL,CAAkBH,EAAE,CAACI,aAAH,CAAiB,OAAjB,EAA0BC,SAA5C,CADG;AAEVC,UAAAA,WAAW,EAAE5B,eAAe,CAAC,KAAKyB,YAAL,CAAkBH,EAAE,CAACI,aAAH,CAAiB,aAAjB,EAAgCC,SAAlD,CAAD,CAFlB;AAGVE,UAAAA,IAAI,EAAEP,EAAE,CAACI,aAAH,CAAiB,MAAjB,EAAyBC;AAHrB,SAAd;AAKAP,QAAAA,WAAW,CAACU,IAAZ,CAAiBP,OAAjB;AACH,OAPD;AAQAd,MAAAA,MAAM,CAACC,IAAP,GAAcU,WAAd;AACA,aAAOX,MAAP;AACH,KAnBY,EAoBZsB,KApBY,CAoBN,UAAUpB,KAAV,EAAiB;AACpBF,MAAAA,MAAM,CAACE,KAAP,GAAeA,KAAK,CAACqB,OAArB;AACA,aAAOvB,MAAP;AACH,KAvBY,CAAjB;AAyBA,WAAOC,IAAP;AACH;AAED;;;;;;;AAKA,SAAOe,YAAP,CAAoBQ,OAApB,EAA6B;AACzB,WAAOA,OAAO,CAACC,OAAR,CAAgB,cAAhB,EAAgC,EAAhC,EAAoCA,OAApC,CAA4C,QAA5C,EAAsD,EAAtD,CAAP;AACH;;AA7CoB","sourcesContent":["\r\nimport ReactHtmlParser from 'react-html-parser';\r\nimport axios from 'axios';\r\nconst headers = new Headers({\r\n    Accept: \"application/xml\",\r\n    \"Content-Type\": \"application/xml; charset=utf-8\",\r\n    //'content-type': 'application/x-www-form-urlencoded',\r\n    'Access-Control-Allow-Origin': '*',\r\n    'Access-Control-Allow-Methods': 'GET, POST, PUT',\r\n    'Access-Control-Allow-Headers': 'Content-Type',\r\n    mode: 'no-cors'\r\n});\r\nexport default class API {\r\n\r\n    /**\r\n     * @method getRSSFeedDetails static method to fetch rss feed from the url\r\n     * @param {String} RSS_URL to fetch the rss feed from the api\r\n     * @returns {Object} data is an array of objects holding title, description and link\r\n     * @returns {string} error is an error message\r\n     */\r\n    static async getRSSFeedDetails(RSS_URL) {\r\n        let result = { data: [], error: '' };\r\n        let data = await axios\r\n            .get(`https://cors-anywhere.herokuapp.com/${RSS_URL}`, headers)\r\n            .then(function (response) {\r\n                let data = response.data;\r\n                return new window.DOMParser().parseFromString(data, \"text/xml\")\r\n            })\r\n            .then(data => {\r\n                const items = data.querySelectorAll(\"item\");\r\n                let articleList = [];\r\n                items.forEach((el) => {\r\n                    let article = {\r\n                        title: this.ReplaceCDATA(el.querySelector(\"title\").innerHTML),\r\n                        description: ReactHtmlParser(this.ReplaceCDATA(el.querySelector(\"description\").innerHTML)),\r\n                        link: el.querySelector(\"link\").innerHTML\r\n                    };\r\n                    articleList.push(article);\r\n                });\r\n                result.data = articleList;\r\n                return result;\r\n            })\r\n            .catch(function (error) {\r\n                result.error = error.message;\r\n                return result;\r\n            });\r\n\r\n        return data;\r\n    }\r\n\r\n    /**\r\n     * @method ReplaceCDATA is to remove the CDATA from the string using replace function\r\n     * @param {String} content \r\n     * @return {String} content without CDATA\r\n     */\r\n    static ReplaceCDATA(content) {\r\n        return content.replace(/<!\\[CDATA\\[/g, '').replace(/\\]\\]>/g, '');\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}